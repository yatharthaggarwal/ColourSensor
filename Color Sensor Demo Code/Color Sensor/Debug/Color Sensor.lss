
Color Sensor.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000024  00800200  000006de  00000772  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000006de  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000001c  00800224  00800224  00000796  2**0
                  ALLOC
  3 .stab         000006e4  00000000  00000000  00000798  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00000e7c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000a0  00000000  00000000  00000f08  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000d82  00000000  00000000  00000fa8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000001ee  00000000  00000000  00001d2a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000593  00000000  00000000  00001f18  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001e8  00000000  00000000  000024ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000003fe  00000000  00000000  00002694  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000038f  00000000  00000000  00002a92  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
   4:	0c 94 13 02 	jmp	0x426	; 0x426 <__vector_1>
   8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
   c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  10:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  14:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  18:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  1c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  20:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  24:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  28:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  2c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  30:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  34:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  38:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  3c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  40:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  44:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  48:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  4c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  50:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  54:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  58:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  5c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  60:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  64:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  68:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  6c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  70:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  74:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  78:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  7c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  80:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  84:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  88:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  8c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  90:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  94:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  98:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  9c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  a0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  a4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  a8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  ac:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  b0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  b4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  b8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  bc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  c0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  c4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  c8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  cc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  d0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  d4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  d8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  dc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  e0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
  f4:	12 e0       	ldi	r17, 0x02	; 2
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	ee ed       	ldi	r30, 0xDE	; 222
  fc:	f6 e0       	ldi	r31, 0x06	; 6
  fe:	00 e0       	ldi	r16, 0x00	; 0
 100:	0b bf       	out	0x3b, r16	; 59
 102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
 104:	07 90       	elpm	r0, Z+
 106:	0d 92       	st	X+, r0
 108:	a4 32       	cpi	r26, 0x24	; 36
 10a:	b1 07       	cpc	r27, r17
 10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
 10e:	12 e0       	ldi	r17, 0x02	; 2
 110:	a4 e2       	ldi	r26, 0x24	; 36
 112:	b2 e0       	ldi	r27, 0x02	; 2
 114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
 116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
 118:	a0 34       	cpi	r26, 0x40	; 64
 11a:	b1 07       	cpc	r27, r17
 11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
 11e:	0e 94 2f 03 	call	0x65e	; 0x65e <main>
 122:	0c 94 6d 03 	jmp	0x6da	; 0x6da <_exit>

00000126 <__bad_interrupt>:
 126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012a <_Z12lcd_set_4bitv>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 12a:	86 e6       	ldi	r24, 0x66	; 102
 12c:	9e e0       	ldi	r25, 0x0E	; 14
 12e:	01 97       	sbiw	r24, 0x01	; 1
 130:	f1 f7       	brne	.-4      	; 0x12e <_Z12lcd_set_4bitv+0x4>
 132:	00 00       	nop
//Function to Reset LCD
void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
 134:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
 136:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
 138:	80 e3       	ldi	r24, 0x30	; 48
 13a:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
 13c:	42 9a       	sbi	0x08, 2	; 8
 13e:	ef ef       	ldi	r30, 0xFF	; 255
 140:	f7 e4       	ldi	r31, 0x47	; 71
 142:	31 97       	sbiw	r30, 0x01	; 1
 144:	f1 f7       	brne	.-4      	; 0x142 <_Z12lcd_set_4bitv+0x18>
 146:	00 c0       	rjmp	.+0      	; 0x148 <_Z12lcd_set_4bitv+0x1e>
 148:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
 14a:	42 98       	cbi	0x08, 2	; 8
 14c:	e6 e6       	ldi	r30, 0x66	; 102
 14e:	fe e0       	ldi	r31, 0x0E	; 14
 150:	31 97       	sbiw	r30, 0x01	; 1
 152:	f1 f7       	brne	.-4      	; 0x150 <_Z12lcd_set_4bitv+0x26>
 154:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
 156:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
 158:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
 15a:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
 15c:	42 9a       	sbi	0x08, 2	; 8
 15e:	ef ef       	ldi	r30, 0xFF	; 255
 160:	f7 e4       	ldi	r31, 0x47	; 71
 162:	31 97       	sbiw	r30, 0x01	; 1
 164:	f1 f7       	brne	.-4      	; 0x162 <_Z12lcd_set_4bitv+0x38>
 166:	00 c0       	rjmp	.+0      	; 0x168 <_Z12lcd_set_4bitv+0x3e>
 168:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
 16a:	42 98       	cbi	0x08, 2	; 8
 16c:	e6 e6       	ldi	r30, 0x66	; 102
 16e:	fe e0       	ldi	r31, 0x0E	; 14
 170:	31 97       	sbiw	r30, 0x01	; 1
 172:	f1 f7       	brne	.-4      	; 0x170 <_Z12lcd_set_4bitv+0x46>
 174:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
 176:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
 178:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
 17a:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
 17c:	42 9a       	sbi	0x08, 2	; 8
 17e:	8f ef       	ldi	r24, 0xFF	; 255
 180:	97 e4       	ldi	r25, 0x47	; 71
 182:	01 97       	sbiw	r24, 0x01	; 1
 184:	f1 f7       	brne	.-4      	; 0x182 <_Z12lcd_set_4bitv+0x58>
 186:	00 c0       	rjmp	.+0      	; 0x188 <_Z12lcd_set_4bitv+0x5e>
 188:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
 18a:	42 98       	cbi	0x08, 2	; 8
 18c:	e6 e6       	ldi	r30, 0x66	; 102
 18e:	fe e0       	ldi	r31, 0x0E	; 14
 190:	31 97       	sbiw	r30, 0x01	; 1
 192:	f1 f7       	brne	.-4      	; 0x190 <_Z12lcd_set_4bitv+0x66>
 194:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
 196:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
 198:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
 19a:	80 e2       	ldi	r24, 0x20	; 32
 19c:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
 19e:	42 9a       	sbi	0x08, 2	; 8
 1a0:	8f ef       	ldi	r24, 0xFF	; 255
 1a2:	97 e4       	ldi	r25, 0x47	; 71
 1a4:	01 97       	sbiw	r24, 0x01	; 1
 1a6:	f1 f7       	brne	.-4      	; 0x1a4 <_Z12lcd_set_4bitv+0x7a>
 1a8:	00 c0       	rjmp	.+0      	; 0x1aa <_Z12lcd_set_4bitv+0x80>
 1aa:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
 1ac:	42 98       	cbi	0x08, 2	; 8

	
}
 1ae:	08 95       	ret

000001b0 <_Z14lcd_wr_commandh>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
 1b0:	98 b1       	in	r25, 0x08	; 8
 1b2:	9f 70       	andi	r25, 0x0F	; 15
 1b4:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
 1b6:	98 b1       	in	r25, 0x08	; 8
//Function to Write Command on LCD
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
 1b8:	28 2f       	mov	r18, r24
 1ba:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
 1bc:	92 2b       	or	r25, r18
 1be:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
 1c0:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
 1c2:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
 1c4:	42 9a       	sbi	0x08, 2	; 8
 1c6:	ef ef       	ldi	r30, 0xFF	; 255
 1c8:	f7 e4       	ldi	r31, 0x47	; 71
 1ca:	31 97       	sbiw	r30, 0x01	; 1
 1cc:	f1 f7       	brne	.-4      	; 0x1ca <_Z14lcd_wr_commandh+0x1a>
 1ce:	00 c0       	rjmp	.+0      	; 0x1d0 <_Z14lcd_wr_commandh+0x20>
 1d0:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
 1d2:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
 1d4:	98 b1       	in	r25, 0x08	; 8
 1d6:	9f 70       	andi	r25, 0x0F	; 15
 1d8:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
 1da:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
 1dc:	82 95       	swap	r24
 1de:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
 1e0:	89 2b       	or	r24, r25
 1e2:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
 1e4:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
 1e6:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
 1e8:	42 9a       	sbi	0x08, 2	; 8
 1ea:	8f ef       	ldi	r24, 0xFF	; 255
 1ec:	97 e4       	ldi	r25, 0x47	; 71
 1ee:	01 97       	sbiw	r24, 0x01	; 1
 1f0:	f1 f7       	brne	.-4      	; 0x1ee <_Z14lcd_wr_commandh+0x3e>
 1f2:	00 c0       	rjmp	.+0      	; 0x1f4 <_Z14lcd_wr_commandh+0x44>
 1f4:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
 1f6:	42 98       	cbi	0x08, 2	; 8
}
 1f8:	08 95       	ret

000001fa <_Z8lcd_initv>:
}

//Function to Initialize LCD
void lcd_init()
{
	lcd_set_4bit();
 1fa:	0e 94 95 00 	call	0x12a	; 0x12a <_Z12lcd_set_4bitv>
 1fe:	86 e6       	ldi	r24, 0x66	; 102
 200:	9e e0       	ldi	r25, 0x0E	; 14
 202:	01 97       	sbiw	r24, 0x01	; 1
 204:	f1 f7       	brne	.-4      	; 0x202 <_Z8lcd_initv+0x8>
 206:	00 00       	nop
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
 208:	88 e2       	ldi	r24, 0x28	; 40
 20a:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <_Z14lcd_wr_commandh>
	lcd_wr_command(0x01);
 20e:	81 e0       	ldi	r24, 0x01	; 1
 210:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <_Z14lcd_wr_commandh>
	lcd_wr_command(0x06);
 214:	86 e0       	ldi	r24, 0x06	; 6
 216:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <_Z14lcd_wr_commandh>
	lcd_wr_command(0x0E);
 21a:	8e e0       	ldi	r24, 0x0E	; 14
 21c:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <_Z14lcd_wr_commandh>
	lcd_wr_command(0x80);
 220:	80 e8       	ldi	r24, 0x80	; 128
 222:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <_Z14lcd_wr_commandh>
		
}
 226:	08 95       	ret

00000228 <_Z11lcd_wr_charc>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
 228:	98 b1       	in	r25, 0x08	; 8
 22a:	9f 70       	andi	r25, 0x0F	; 15
 22c:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
 22e:	98 b1       	in	r25, 0x08	; 8
//Function to Write Data on LCD
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
 230:	28 2f       	mov	r18, r24
 232:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
 234:	92 2b       	or	r25, r18
 236:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
 238:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
 23a:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
 23c:	42 9a       	sbi	0x08, 2	; 8
 23e:	ef ef       	ldi	r30, 0xFF	; 255
 240:	f7 e4       	ldi	r31, 0x47	; 71
 242:	31 97       	sbiw	r30, 0x01	; 1
 244:	f1 f7       	brne	.-4      	; 0x242 <_Z11lcd_wr_charc+0x1a>
 246:	00 c0       	rjmp	.+0      	; 0x248 <_Z11lcd_wr_charc+0x20>
 248:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
 24a:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
 24c:	98 b1       	in	r25, 0x08	; 8
 24e:	9f 70       	andi	r25, 0x0F	; 15
 250:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
 252:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
 254:	82 95       	swap	r24
 256:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
 258:	89 2b       	or	r24, r25
 25a:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
 25c:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
 25e:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
 260:	42 9a       	sbi	0x08, 2	; 8
 262:	8f ef       	ldi	r24, 0xFF	; 255
 264:	97 e4       	ldi	r25, 0x47	; 71
 266:	01 97       	sbiw	r24, 0x01	; 1
 268:	f1 f7       	brne	.-4      	; 0x266 <_Z11lcd_wr_charc+0x3e>
 26a:	00 c0       	rjmp	.+0      	; 0x26c <_Z11lcd_wr_charc+0x44>
 26c:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
 26e:	42 98       	cbi	0x08, 2	; 8
}
 270:	08 95       	ret

00000272 <_Z8lcd_homev>:


//Function to bring cursor at home position
void lcd_home()
{
	lcd_wr_command(0x80);
 272:	80 e8       	ldi	r24, 0x80	; 128
 274:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <_Z14lcd_wr_commandh>
}
 278:	08 95       	ret

0000027a <_Z10lcd_stringPc>:


//Function to Print String on LCD
void lcd_string(char *str)
{
 27a:	cf 93       	push	r28
 27c:	df 93       	push	r29
 27e:	ec 01       	movw	r28, r24
	while(*str != '\0')
 280:	88 81       	ld	r24, Y
 282:	88 23       	and	r24, r24
 284:	31 f0       	breq	.+12     	; 0x292 <_Z10lcd_stringPc+0x18>
	lcd_wr_command(0x80);
}


//Function to Print String on LCD
void lcd_string(char *str)
 286:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
 288:	0e 94 14 01 	call	0x228	; 0x228 <_Z11lcd_wr_charc>


//Function to Print String on LCD
void lcd_string(char *str)
{
	while(*str != '\0')
 28c:	89 91       	ld	r24, Y+
 28e:	88 23       	and	r24, r24
 290:	d9 f7       	brne	.-10     	; 0x288 <_Z10lcd_stringPc+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
 292:	df 91       	pop	r29
 294:	cf 91       	pop	r28
 296:	08 95       	ret

00000298 <_Z10lcd_cursorcc>:

//Position the LCD cursor at "row", "column".

void lcd_cursor (char row, char column)
{
	switch (row) {
 298:	82 30       	cpi	r24, 0x02	; 2
 29a:	79 f0       	breq	.+30     	; 0x2ba <_Z10lcd_cursorcc+0x22>
 29c:	83 30       	cpi	r24, 0x03	; 3
 29e:	18 f4       	brcc	.+6      	; 0x2a6 <_Z10lcd_cursorcc+0xe>
 2a0:	81 30       	cpi	r24, 0x01	; 1
 2a2:	c9 f4       	brne	.+50     	; 0x2d6 <_Z10lcd_cursorcc+0x3e>
 2a4:	05 c0       	rjmp	.+10     	; 0x2b0 <_Z10lcd_cursorcc+0x18>
 2a6:	83 30       	cpi	r24, 0x03	; 3
 2a8:	69 f0       	breq	.+26     	; 0x2c4 <_Z10lcd_cursorcc+0x2c>
 2aa:	84 30       	cpi	r24, 0x04	; 4
 2ac:	a1 f4       	brne	.+40     	; 0x2d6 <_Z10lcd_cursorcc+0x3e>
 2ae:	0f c0       	rjmp	.+30     	; 0x2ce <_Z10lcd_cursorcc+0x36>
		case 1: lcd_wr_command (0x80 + column - 1); break;
 2b0:	86 2f       	mov	r24, r22
 2b2:	81 58       	subi	r24, 0x81	; 129
 2b4:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <_Z14lcd_wr_commandh>
 2b8:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
 2ba:	86 2f       	mov	r24, r22
 2bc:	81 54       	subi	r24, 0x41	; 65
 2be:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <_Z14lcd_wr_commandh>
 2c2:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
 2c4:	86 2f       	mov	r24, r22
 2c6:	8d 56       	subi	r24, 0x6D	; 109
 2c8:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <_Z14lcd_wr_commandh>
 2cc:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
 2ce:	86 2f       	mov	r24, r22
 2d0:	8d 52       	subi	r24, 0x2D	; 45
 2d2:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <_Z14lcd_wr_commandh>
 2d6:	08 95       	ret

000002d8 <_Z9lcd_printccji>:
	}
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
 2d8:	0f 93       	push	r16
 2da:	1f 93       	push	r17
 2dc:	cf 93       	push	r28
 2de:	df 93       	push	r29
 2e0:	8a 01       	movw	r16, r20
 2e2:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
 2e4:	88 23       	and	r24, r24
 2e6:	11 f0       	breq	.+4      	; 0x2ec <_Z9lcd_printccji+0x14>
 2e8:	66 23       	and	r22, r22
 2ea:	19 f4       	brne	.+6      	; 0x2f2 <_Z9lcd_printccji+0x1a>
	{
		lcd_home();
 2ec:	0e 94 39 01 	call	0x272	; 0x272 <_Z8lcd_homev>
 2f0:	02 c0       	rjmp	.+4      	; 0x2f6 <_Z9lcd_printccji+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
 2f2:	0e 94 4c 01 	call	0x298	; 0x298 <_Z10lcd_cursorcc>
	}
	if(digits==5 || flag==1)
 2f6:	c5 30       	cpi	r28, 0x05	; 5
 2f8:	d1 05       	cpc	r29, r1
 2fa:	71 f4       	brne	.+28     	; 0x318 <_Z9lcd_printccji+0x40>
	{
		million=value/10000+48;
 2fc:	c8 01       	movw	r24, r16
 2fe:	60 e1       	ldi	r22, 0x10	; 16
 300:	77 e2       	ldi	r23, 0x27	; 39
 302:	0e 94 59 03 	call	0x6b2	; 0x6b2 <__udivmodhi4>
 306:	cb 01       	movw	r24, r22
 308:	c0 96       	adiw	r24, 0x30	; 48
 30a:	90 93 35 02 	sts	0x0235, r25
 30e:	80 93 34 02 	sts	0x0234, r24
		lcd_wr_char(million);
 312:	0e 94 14 01 	call	0x228	; 0x228 <_Z11lcd_wr_charc>
 316:	03 c0       	rjmp	.+6      	; 0x31e <_Z9lcd_printccji+0x46>
		flag=1;
	}
	if(digits==4 || flag==1)
 318:	c4 30       	cpi	r28, 0x04	; 4
 31a:	d1 05       	cpc	r29, r1
 31c:	b9 f4       	brne	.+46     	; 0x34c <_Z9lcd_printccji+0x74>
	{
		temp = value/1000;
 31e:	c8 01       	movw	r24, r16
 320:	68 ee       	ldi	r22, 0xE8	; 232
 322:	73 e0       	ldi	r23, 0x03	; 3
 324:	0e 94 59 03 	call	0x6b2	; 0x6b2 <__udivmodhi4>
 328:	cb 01       	movw	r24, r22
 32a:	70 93 3f 02 	sts	0x023F, r23
 32e:	60 93 3e 02 	sts	0x023E, r22
		thousand = temp%10 + 48;
 332:	6a e0       	ldi	r22, 0x0A	; 10
 334:	70 e0       	ldi	r23, 0x00	; 0
 336:	0e 94 59 03 	call	0x6b2	; 0x6b2 <__udivmodhi4>
 33a:	c0 96       	adiw	r24, 0x30	; 48
 33c:	90 93 37 02 	sts	0x0237, r25
 340:	80 93 36 02 	sts	0x0236, r24
		lcd_wr_char(thousand);
 344:	0e 94 14 01 	call	0x228	; 0x228 <_Z11lcd_wr_charc>
		flag=1;
 348:	81 e0       	ldi	r24, 0x01	; 1
 34a:	01 c0       	rjmp	.+2      	; 0x34e <_Z9lcd_printccji+0x76>
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
	unsigned char flag=0;
 34c:	80 e0       	ldi	r24, 0x00	; 0
		temp = value/1000;
		thousand = temp%10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
	if(digits==3 || flag==1)
 34e:	c3 30       	cpi	r28, 0x03	; 3
 350:	d1 05       	cpc	r29, r1
 352:	11 f0       	breq	.+4      	; 0x358 <_Z9lcd_printccji+0x80>
 354:	81 30       	cpi	r24, 0x01	; 1
 356:	b1 f4       	brne	.+44     	; 0x384 <_Z9lcd_printccji+0xac>
	{
		temp = value/100;
 358:	c8 01       	movw	r24, r16
 35a:	64 e6       	ldi	r22, 0x64	; 100
 35c:	70 e0       	ldi	r23, 0x00	; 0
 35e:	0e 94 59 03 	call	0x6b2	; 0x6b2 <__udivmodhi4>
 362:	cb 01       	movw	r24, r22
 364:	70 93 3f 02 	sts	0x023F, r23
 368:	60 93 3e 02 	sts	0x023E, r22
		hundred = temp%10 + 48;
 36c:	6a e0       	ldi	r22, 0x0A	; 10
 36e:	70 e0       	ldi	r23, 0x00	; 0
 370:	0e 94 59 03 	call	0x6b2	; 0x6b2 <__udivmodhi4>
 374:	c0 96       	adiw	r24, 0x30	; 48
 376:	90 93 39 02 	sts	0x0239, r25
 37a:	80 93 38 02 	sts	0x0238, r24
		lcd_wr_char(hundred);
 37e:	0e 94 14 01 	call	0x228	; 0x228 <_Z11lcd_wr_charc>
		flag=1;
 382:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==2 || flag==1)
 384:	c2 30       	cpi	r28, 0x02	; 2
 386:	d1 05       	cpc	r29, r1
 388:	11 f0       	breq	.+4      	; 0x38e <_Z9lcd_printccji+0xb6>
 38a:	81 30       	cpi	r24, 0x01	; 1
 38c:	b1 f4       	brne	.+44     	; 0x3ba <_Z9lcd_printccji+0xe2>
	{
		temp = value/10;
 38e:	2a e0       	ldi	r18, 0x0A	; 10
 390:	30 e0       	ldi	r19, 0x00	; 0
 392:	c8 01       	movw	r24, r16
 394:	b9 01       	movw	r22, r18
 396:	0e 94 59 03 	call	0x6b2	; 0x6b2 <__udivmodhi4>
 39a:	cb 01       	movw	r24, r22
 39c:	70 93 3f 02 	sts	0x023F, r23
 3a0:	60 93 3e 02 	sts	0x023E, r22
		tens = temp%10 + 48;
 3a4:	b9 01       	movw	r22, r18
 3a6:	0e 94 59 03 	call	0x6b2	; 0x6b2 <__udivmodhi4>
 3aa:	c0 96       	adiw	r24, 0x30	; 48
 3ac:	90 93 3b 02 	sts	0x023B, r25
 3b0:	80 93 3a 02 	sts	0x023A, r24
		lcd_wr_char(tens);
 3b4:	0e 94 14 01 	call	0x228	; 0x228 <_Z11lcd_wr_charc>
		flag=1;
 3b8:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==1 || flag==1)
 3ba:	c1 30       	cpi	r28, 0x01	; 1
 3bc:	d1 05       	cpc	r29, r1
 3be:	11 f0       	breq	.+4      	; 0x3c4 <_Z9lcd_printccji+0xec>
 3c0:	81 30       	cpi	r24, 0x01	; 1
 3c2:	61 f4       	brne	.+24     	; 0x3dc <_Z9lcd_printccji+0x104>
	{
		unit = value%10 + 48;
 3c4:	c8 01       	movw	r24, r16
 3c6:	6a e0       	ldi	r22, 0x0A	; 10
 3c8:	70 e0       	ldi	r23, 0x00	; 0
 3ca:	0e 94 59 03 	call	0x6b2	; 0x6b2 <__udivmodhi4>
 3ce:	c0 96       	adiw	r24, 0x30	; 48
 3d0:	90 93 3d 02 	sts	0x023D, r25
 3d4:	80 93 3c 02 	sts	0x023C, r24
		lcd_wr_char(unit);
 3d8:	0e 94 14 01 	call	0x228	; 0x228 <_Z11lcd_wr_charc>
	}
	if(digits>5)
 3dc:	c6 30       	cpi	r28, 0x06	; 6
 3de:	d1 05       	cpc	r29, r1
 3e0:	1c f0       	brlt	.+6      	; 0x3e8 <_Z9lcd_printccji+0x110>
	{
		lcd_wr_char('E');
 3e2:	85 e4       	ldi	r24, 0x45	; 69
 3e4:	0e 94 14 01 	call	0x228	; 0x228 <_Z11lcd_wr_charc>
	}
	
}
 3e8:	df 91       	pop	r29
 3ea:	cf 91       	pop	r28
 3ec:	1f 91       	pop	r17
 3ee:	0f 91       	pop	r16
 3f0:	08 95       	ret

000003f2 <_Z15lcd_port_configv>:
volatile unsigned long int blue;      // variable to store the pulse count when read_blue function is called
volatile unsigned long int green;     // variable to store the pulse count when read_green function is called

void lcd_port_config (void)
{
	DDRC = DDRC | 0xF7; //setting all the LCD pin's direction set as output
 3f2:	87 b1       	in	r24, 0x07	; 7
 3f4:	87 6f       	ori	r24, 0xF7	; 247
 3f6:	87 b9       	out	0x07, r24	; 7
	PORTC = PORTC & 0x80; //setting all the LCD pins are set to logic 0 except PORTC 7
 3f8:	88 b1       	in	r24, 0x08	; 8
 3fa:	80 78       	andi	r24, 0x80	; 128
 3fc:	88 b9       	out	0x08, r24	; 8
}
 3fe:	08 95       	ret

00000400 <_Z23color_sensor_pin_configv>:

void color_sensor_pin_config(void)
{
	DDRD  = DDRD | 0xFE; //set PD0 as input for color sensor output
 400:	8a b1       	in	r24, 0x0a	; 10
 402:	8e 6f       	ori	r24, 0xFE	; 254
 404:	8a b9       	out	0x0a, r24	; 10
	PORTD = PORTD | 0x01;//Enable internal pull-up for PORTD 0 pin
 406:	58 9a       	sbi	0x0b, 0	; 11
}
 408:	08 95       	ret

0000040a <_Z9port_initv>:

void port_init(void)
{
	lcd_port_config();//lcd pin configuration
 40a:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <_Z15lcd_port_configv>
	color_sensor_pin_config();//color sensor pin configuration
 40e:	0e 94 00 02 	call	0x400	; 0x400 <_Z23color_sensor_pin_configv>
}
 412:	08 95       	ret

00000414 <_Z31color_sensor_pin_interrupt_initv>:

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
 414:	f8 94       	cli
	EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
 416:	e9 e6       	ldi	r30, 0x69	; 105
 418:	f0 e0       	ldi	r31, 0x00	; 0
 41a:	80 81       	ld	r24, Z
 41c:	82 60       	ori	r24, 0x02	; 2
 41e:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
 420:	e8 9a       	sbi	0x1d, 0	; 29
	sei(); // Enables the global interrupt
 422:	78 94       	sei
}
 424:	08 95       	ret

00000426 <__vector_1>:

//ISR for color sensor
ISR(INT0_vect)
{
 426:	1f 92       	push	r1
 428:	0f 92       	push	r0
 42a:	0f b6       	in	r0, 0x3f	; 63
 42c:	0f 92       	push	r0
 42e:	11 24       	eor	r1, r1
 430:	8f 93       	push	r24
 432:	9f 93       	push	r25
 434:	af 93       	push	r26
 436:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
 438:	80 91 30 02 	lds	r24, 0x0230
 43c:	90 91 31 02 	lds	r25, 0x0231
 440:	a0 91 32 02 	lds	r26, 0x0232
 444:	b0 91 33 02 	lds	r27, 0x0233
 448:	01 96       	adiw	r24, 0x01	; 1
 44a:	a1 1d       	adc	r26, r1
 44c:	b1 1d       	adc	r27, r1
 44e:	80 93 30 02 	sts	0x0230, r24
 452:	90 93 31 02 	sts	0x0231, r25
 456:	a0 93 32 02 	sts	0x0232, r26
 45a:	b0 93 33 02 	sts	0x0233, r27
}
 45e:	bf 91       	pop	r27
 460:	af 91       	pop	r26
 462:	9f 91       	pop	r25
 464:	8f 91       	pop	r24
 466:	0f 90       	pop	r0
 468:	0f be       	out	0x3f, r0	; 63
 46a:	0f 90       	pop	r0
 46c:	1f 90       	pop	r1
 46e:	18 95       	reti

00000470 <_Z12init_devicesv>:

void init_devices(void)
{
	cli(); //Clears the global interrupt
 470:	f8 94       	cli
	port_init();  //Initializes all the ports
 472:	0e 94 05 02 	call	0x40a	; 0x40a <_Z9port_initv>
	color_sensor_pin_interrupt_init();
 476:	0e 94 0a 02 	call	0x414	; 0x414 <_Z31color_sensor_pin_interrupt_initv>
	sei();   // Enables the global interrupt
 47a:	78 94       	sei
}
 47c:	08 95       	ret

0000047e <_Z10filter_redv>:

//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTD = PORTD & 0xBF; //set S2 low
 47e:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD & 0x7F; //set S3 low
 480:	5f 98       	cbi	0x0b, 7	; 11
}
 482:	08 95       	ret

00000484 <_Z12filter_greenv>:

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTD = PORTD | 0x40; //set S2 High
 484:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
 486:	5f 9a       	sbi	0x0b, 7	; 11
}
 488:	08 95       	ret

0000048a <_Z11filter_bluev>:

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTD = PORTD & 0xBF; //set S2 low
 48a:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
 48c:	5f 9a       	sbi	0x0b, 7	; 11
}
 48e:	08 95       	ret

00000490 <_Z12filter_clearv>:

void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	PORTD = PORTD | 0x40; //set S2 High
 490:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD = PORTD & 0x7F; //set S3 Low
 492:	5f 98       	cbi	0x0b, 7	; 11
}
 494:	08 95       	ret

00000496 <_Z20color_sensor_scalingv>:
//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xEF;
	PORTD = PORTD | 0x10; //set S0 high
 496:	5c 9a       	sbi	0x0b, 4	; 11
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTD = PORTD | 0x20; //set S1 high
 498:	5d 9a       	sbi	0x0b, 5	; 11
}
 49a:	08 95       	ret

0000049c <_Z8red_readv>:

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
 49c:	0f 93       	push	r16
 49e:	1f 93       	push	r17
	//Red
	filter_red(); //select red filter
 4a0:	0e 94 3f 02 	call	0x47e	; 0x47e <_Z10filter_redv>
	pulse=0; //reset the count to 0
 4a4:	10 92 30 02 	sts	0x0230, r1
 4a8:	10 92 31 02 	sts	0x0231, r1
 4ac:	10 92 32 02 	sts	0x0232, r1
 4b0:	10 92 33 02 	sts	0x0233, r1
 4b4:	8f ef       	ldi	r24, 0xFF	; 255
 4b6:	9f e7       	ldi	r25, 0x7F	; 127
 4b8:	a4 e0       	ldi	r26, 0x04	; 4
 4ba:	81 50       	subi	r24, 0x01	; 1
 4bc:	90 40       	sbci	r25, 0x00	; 0
 4be:	a0 40       	sbci	r26, 0x00	; 0
 4c0:	e1 f7       	brne	.-8      	; 0x4ba <_Z8red_readv+0x1e>
 4c2:	00 c0       	rjmp	.+0      	; 0x4c4 <_Z8red_readv+0x28>
 4c4:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
 4c6:	80 91 30 02 	lds	r24, 0x0230
 4ca:	90 91 31 02 	lds	r25, 0x0231
 4ce:	a0 91 32 02 	lds	r26, 0x0232
 4d2:	b0 91 33 02 	lds	r27, 0x0233
 4d6:	80 93 2c 02 	sts	0x022C, r24
 4da:	90 93 2d 02 	sts	0x022D, r25
 4de:	a0 93 2e 02 	sts	0x022E, r26
 4e2:	b0 93 2f 02 	sts	0x022F, r27
	
	lcd_cursor(1,1);  //set the cursor on row 1, column 1
 4e6:	81 e0       	ldi	r24, 0x01	; 1
 4e8:	61 e0       	ldi	r22, 0x01	; 1
 4ea:	0e 94 4c 01 	call	0x298	; 0x298 <_Z10lcd_cursorcc>
	lcd_string("Red Pulses"); // Display "Red Pulses" on LCD
 4ee:	80 e0       	ldi	r24, 0x00	; 0
 4f0:	92 e0       	ldi	r25, 0x02	; 2
 4f2:	0e 94 3d 01 	call	0x27a	; 0x27a <_Z10lcd_stringPc>
	lcd_print(2,1,red,5);  //Print the count on second row
 4f6:	00 91 2c 02 	lds	r16, 0x022C
 4fa:	10 91 2d 02 	lds	r17, 0x022D
 4fe:	20 91 2e 02 	lds	r18, 0x022E
 502:	30 91 2f 02 	lds	r19, 0x022F
 506:	82 e0       	ldi	r24, 0x02	; 2
 508:	61 e0       	ldi	r22, 0x01	; 1
 50a:	a8 01       	movw	r20, r16
 50c:	25 e0       	ldi	r18, 0x05	; 5
 50e:	30 e0       	ldi	r19, 0x00	; 0
 510:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <_Z9lcd_printccji>
 514:	8f ef       	ldi	r24, 0xFF	; 255
 516:	9f ef       	ldi	r25, 0xFF	; 255
 518:	ac e2       	ldi	r26, 0x2C	; 44
 51a:	81 50       	subi	r24, 0x01	; 1
 51c:	90 40       	sbci	r25, 0x00	; 0
 51e:	a0 40       	sbci	r26, 0x00	; 0
 520:	e1 f7       	brne	.-8      	; 0x51a <_Z8red_readv+0x7e>
 522:	00 c0       	rjmp	.+0      	; 0x524 <_Z8red_readv+0x88>
 524:	00 00       	nop
	_delay_ms(1000);	// Display for 1000ms or 1 second
	lcd_wr_command(0x01); //Clear the LCD
 526:	81 e0       	ldi	r24, 0x01	; 1
 528:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <_Z14lcd_wr_commandh>
}
 52c:	1f 91       	pop	r17
 52e:	0f 91       	pop	r16
 530:	08 95       	ret

00000532 <_Z10green_readv>:

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
 532:	0f 93       	push	r16
 534:	1f 93       	push	r17
	//Green
	filter_green(); //select green filter
 536:	0e 94 42 02 	call	0x484	; 0x484 <_Z12filter_greenv>
	pulse=0; //reset the count to 0
 53a:	10 92 30 02 	sts	0x0230, r1
 53e:	10 92 31 02 	sts	0x0231, r1
 542:	10 92 32 02 	sts	0x0232, r1
 546:	10 92 33 02 	sts	0x0233, r1
 54a:	8f ef       	ldi	r24, 0xFF	; 255
 54c:	9f e7       	ldi	r25, 0x7F	; 127
 54e:	a4 e0       	ldi	r26, 0x04	; 4
 550:	81 50       	subi	r24, 0x01	; 1
 552:	90 40       	sbci	r25, 0x00	; 0
 554:	a0 40       	sbci	r26, 0x00	; 0
 556:	e1 f7       	brne	.-8      	; 0x550 <_Z10green_readv+0x1e>
 558:	00 c0       	rjmp	.+0      	; 0x55a <_Z10green_readv+0x28>
 55a:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
 55c:	80 91 30 02 	lds	r24, 0x0230
 560:	90 91 31 02 	lds	r25, 0x0231
 564:	a0 91 32 02 	lds	r26, 0x0232
 568:	b0 91 33 02 	lds	r27, 0x0233
 56c:	80 93 24 02 	sts	0x0224, r24
 570:	90 93 25 02 	sts	0x0225, r25
 574:	a0 93 26 02 	sts	0x0226, r26
 578:	b0 93 27 02 	sts	0x0227, r27
	
	lcd_cursor(1,1);  //set the cursor on row 1, column 1
 57c:	81 e0       	ldi	r24, 0x01	; 1
 57e:	61 e0       	ldi	r22, 0x01	; 1
 580:	0e 94 4c 01 	call	0x298	; 0x298 <_Z10lcd_cursorcc>
	lcd_string("Green Pulses"); // Display "Green Pulses" on LCD
 584:	8b e0       	ldi	r24, 0x0B	; 11
 586:	92 e0       	ldi	r25, 0x02	; 2
 588:	0e 94 3d 01 	call	0x27a	; 0x27a <_Z10lcd_stringPc>
	lcd_print(2,1,green,5);  //Print the count on second row
 58c:	00 91 24 02 	lds	r16, 0x0224
 590:	10 91 25 02 	lds	r17, 0x0225
 594:	20 91 26 02 	lds	r18, 0x0226
 598:	30 91 27 02 	lds	r19, 0x0227
 59c:	82 e0       	ldi	r24, 0x02	; 2
 59e:	61 e0       	ldi	r22, 0x01	; 1
 5a0:	a8 01       	movw	r20, r16
 5a2:	25 e0       	ldi	r18, 0x05	; 5
 5a4:	30 e0       	ldi	r19, 0x00	; 0
 5a6:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <_Z9lcd_printccji>
 5aa:	8f ef       	ldi	r24, 0xFF	; 255
 5ac:	9f ef       	ldi	r25, 0xFF	; 255
 5ae:	ac e2       	ldi	r26, 0x2C	; 44
 5b0:	81 50       	subi	r24, 0x01	; 1
 5b2:	90 40       	sbci	r25, 0x00	; 0
 5b4:	a0 40       	sbci	r26, 0x00	; 0
 5b6:	e1 f7       	brne	.-8      	; 0x5b0 <_Z10green_readv+0x7e>
 5b8:	00 c0       	rjmp	.+0      	; 0x5ba <_Z10green_readv+0x88>
 5ba:	00 00       	nop
	_delay_ms(1000);	// Display for 1000ms or 1 second
	lcd_wr_command(0x01); //Clear the LCD
 5bc:	81 e0       	ldi	r24, 0x01	; 1
 5be:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <_Z14lcd_wr_commandh>
}
 5c2:	1f 91       	pop	r17
 5c4:	0f 91       	pop	r16
 5c6:	08 95       	ret

000005c8 <_Z9blue_readv>:

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
 5c8:	0f 93       	push	r16
 5ca:	1f 93       	push	r17
	//Blue
	filter_blue(); //select blue filter
 5cc:	0e 94 45 02 	call	0x48a	; 0x48a <_Z11filter_bluev>
	pulse=0; //reset the count to 0
 5d0:	10 92 30 02 	sts	0x0230, r1
 5d4:	10 92 31 02 	sts	0x0231, r1
 5d8:	10 92 32 02 	sts	0x0232, r1
 5dc:	10 92 33 02 	sts	0x0233, r1
 5e0:	8f ef       	ldi	r24, 0xFF	; 255
 5e2:	9f e7       	ldi	r25, 0x7F	; 127
 5e4:	a4 e0       	ldi	r26, 0x04	; 4
 5e6:	81 50       	subi	r24, 0x01	; 1
 5e8:	90 40       	sbci	r25, 0x00	; 0
 5ea:	a0 40       	sbci	r26, 0x00	; 0
 5ec:	e1 f7       	brne	.-8      	; 0x5e6 <_Z9blue_readv+0x1e>
 5ee:	00 c0       	rjmp	.+0      	; 0x5f0 <_Z9blue_readv+0x28>
 5f0:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
 5f2:	80 91 30 02 	lds	r24, 0x0230
 5f6:	90 91 31 02 	lds	r25, 0x0231
 5fa:	a0 91 32 02 	lds	r26, 0x0232
 5fe:	b0 91 33 02 	lds	r27, 0x0233
 602:	80 93 28 02 	sts	0x0228, r24
 606:	90 93 29 02 	sts	0x0229, r25
 60a:	a0 93 2a 02 	sts	0x022A, r26
 60e:	b0 93 2b 02 	sts	0x022B, r27
	
	lcd_cursor(1,1);  //set the cursor on row 1, column 1
 612:	81 e0       	ldi	r24, 0x01	; 1
 614:	61 e0       	ldi	r22, 0x01	; 1
 616:	0e 94 4c 01 	call	0x298	; 0x298 <_Z10lcd_cursorcc>
	lcd_string("Blue Pulses"); // Display "Blue Pulses" on LCD
 61a:	88 e1       	ldi	r24, 0x18	; 24
 61c:	92 e0       	ldi	r25, 0x02	; 2
 61e:	0e 94 3d 01 	call	0x27a	; 0x27a <_Z10lcd_stringPc>
	lcd_print(2,1,blue,5);  //Print the count on second row
 622:	00 91 28 02 	lds	r16, 0x0228
 626:	10 91 29 02 	lds	r17, 0x0229
 62a:	20 91 2a 02 	lds	r18, 0x022A
 62e:	30 91 2b 02 	lds	r19, 0x022B
 632:	82 e0       	ldi	r24, 0x02	; 2
 634:	61 e0       	ldi	r22, 0x01	; 1
 636:	a8 01       	movw	r20, r16
 638:	25 e0       	ldi	r18, 0x05	; 5
 63a:	30 e0       	ldi	r19, 0x00	; 0
 63c:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <_Z9lcd_printccji>
 640:	8f ef       	ldi	r24, 0xFF	; 255
 642:	9f ef       	ldi	r25, 0xFF	; 255
 644:	ac e2       	ldi	r26, 0x2C	; 44
 646:	81 50       	subi	r24, 0x01	; 1
 648:	90 40       	sbci	r25, 0x00	; 0
 64a:	a0 40       	sbci	r26, 0x00	; 0
 64c:	e1 f7       	brne	.-8      	; 0x646 <_Z9blue_readv+0x7e>
 64e:	00 c0       	rjmp	.+0      	; 0x650 <_Z9blue_readv+0x88>
 650:	00 00       	nop
	_delay_ms(1000);	// Display for 1000ms or 1 second
	lcd_wr_command(0x01); //Clear the LCD
 652:	81 e0       	ldi	r24, 0x01	; 1
 654:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <_Z14lcd_wr_commandh>
}
 658:	1f 91       	pop	r17
 65a:	0f 91       	pop	r16
 65c:	08 95       	ret

0000065e <main>:

int main(void)
{
    init_devices();
 65e:	0e 94 38 02 	call	0x470	; 0x470 <_Z12init_devicesv>
    lcd_set_4bit();
 662:	0e 94 95 00 	call	0x12a	; 0x12a <_Z12lcd_set_4bitv>
    lcd_init();
 666:	0e 94 fd 00 	call	0x1fa	; 0x1fa <_Z8lcd_initv>
	color_sensor_scaling();
 66a:	0e 94 4b 02 	call	0x496	; 0x496 <_Z20color_sensor_scalingv>
	
	while(1)
    {
       red_read(); //display the pulse count when red filter is selected
 66e:	0e 94 4e 02 	call	0x49c	; 0x49c <_Z8red_readv>
 672:	8f ef       	ldi	r24, 0xFF	; 255
 674:	9f e7       	ldi	r25, 0x7F	; 127
 676:	a6 e1       	ldi	r26, 0x16	; 22
 678:	81 50       	subi	r24, 0x01	; 1
 67a:	90 40       	sbci	r25, 0x00	; 0
 67c:	a0 40       	sbci	r26, 0x00	; 0
 67e:	e1 f7       	brne	.-8      	; 0x678 <main+0x1a>
 680:	00 c0       	rjmp	.+0      	; 0x682 <main+0x24>
 682:	00 00       	nop
	   _delay_ms(500);
	   green_read(); //display the pulse count when green filter is selected
 684:	0e 94 99 02 	call	0x532	; 0x532 <_Z10green_readv>
 688:	8f ef       	ldi	r24, 0xFF	; 255
 68a:	9f e7       	ldi	r25, 0x7F	; 127
 68c:	a6 e1       	ldi	r26, 0x16	; 22
 68e:	81 50       	subi	r24, 0x01	; 1
 690:	90 40       	sbci	r25, 0x00	; 0
 692:	a0 40       	sbci	r26, 0x00	; 0
 694:	e1 f7       	brne	.-8      	; 0x68e <main+0x30>
 696:	00 c0       	rjmp	.+0      	; 0x698 <main+0x3a>
 698:	00 00       	nop
	   _delay_ms(500);
	   blue_read(); //display the pulse count when blue filter is selected
 69a:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <_Z9blue_readv>
 69e:	8f ef       	ldi	r24, 0xFF	; 255
 6a0:	9f e7       	ldi	r25, 0x7F	; 127
 6a2:	a6 e1       	ldi	r26, 0x16	; 22
 6a4:	81 50       	subi	r24, 0x01	; 1
 6a6:	90 40       	sbci	r25, 0x00	; 0
 6a8:	a0 40       	sbci	r26, 0x00	; 0
 6aa:	e1 f7       	brne	.-8      	; 0x6a4 <main+0x46>
 6ac:	00 c0       	rjmp	.+0      	; 0x6ae <main+0x50>
 6ae:	00 00       	nop
 6b0:	de cf       	rjmp	.-68     	; 0x66e <main+0x10>

000006b2 <__udivmodhi4>:
 6b2:	aa 1b       	sub	r26, r26
 6b4:	bb 1b       	sub	r27, r27
 6b6:	51 e1       	ldi	r21, 0x11	; 17
 6b8:	07 c0       	rjmp	.+14     	; 0x6c8 <__udivmodhi4_ep>

000006ba <__udivmodhi4_loop>:
 6ba:	aa 1f       	adc	r26, r26
 6bc:	bb 1f       	adc	r27, r27
 6be:	a6 17       	cp	r26, r22
 6c0:	b7 07       	cpc	r27, r23
 6c2:	10 f0       	brcs	.+4      	; 0x6c8 <__udivmodhi4_ep>
 6c4:	a6 1b       	sub	r26, r22
 6c6:	b7 0b       	sbc	r27, r23

000006c8 <__udivmodhi4_ep>:
 6c8:	88 1f       	adc	r24, r24
 6ca:	99 1f       	adc	r25, r25
 6cc:	5a 95       	dec	r21
 6ce:	a9 f7       	brne	.-22     	; 0x6ba <__udivmodhi4_loop>
 6d0:	80 95       	com	r24
 6d2:	90 95       	com	r25
 6d4:	bc 01       	movw	r22, r24
 6d6:	cd 01       	movw	r24, r26
 6d8:	08 95       	ret

000006da <_exit>:
 6da:	f8 94       	cli

000006dc <__stop_program>:
 6dc:	ff cf       	rjmp	.-2      	; 0x6dc <__stop_program>
